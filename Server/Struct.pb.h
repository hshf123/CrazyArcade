// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Struct.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "Enum.pb.h"
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Struct_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_Struct_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_Struct_2eproto;
namespace Protocol {
class PCellPos;
struct PCellPosDefaultTypeInternal;
extern PCellPosDefaultTypeInternal _PCellPos_default_instance_;
class PChannel;
struct PChannelDefaultTypeInternal;
extern PChannelDefaultTypeInternal _PChannel_default_instance_;
class PPlayer;
struct PPlayerDefaultTypeInternal;
extern PPlayerDefaultTypeInternal _PPlayer_default_instance_;
class PPositionInfo;
struct PPositionInfoDefaultTypeInternal;
extern PPositionInfoDefaultTypeInternal _PPositionInfo_default_instance_;
class PRoom;
struct PRoomDefaultTypeInternal;
extern PRoomDefaultTypeInternal _PRoom_default_instance_;
class PRoomStart;
struct PRoomStartDefaultTypeInternal;
extern PRoomStartDefaultTypeInternal _PRoomStart_default_instance_;
class PWorldPos;
struct PWorldPosDefaultTypeInternal;
extern PWorldPosDefaultTypeInternal _PWorldPos_default_instance_;
}  // namespace Protocol
PROTOBUF_NAMESPACE_OPEN
template<> ::Protocol::PCellPos* Arena::CreateMaybeMessage<::Protocol::PCellPos>(Arena*);
template<> ::Protocol::PChannel* Arena::CreateMaybeMessage<::Protocol::PChannel>(Arena*);
template<> ::Protocol::PPlayer* Arena::CreateMaybeMessage<::Protocol::PPlayer>(Arena*);
template<> ::Protocol::PPositionInfo* Arena::CreateMaybeMessage<::Protocol::PPositionInfo>(Arena*);
template<> ::Protocol::PRoom* Arena::CreateMaybeMessage<::Protocol::PRoom>(Arena*);
template<> ::Protocol::PRoomStart* Arena::CreateMaybeMessage<::Protocol::PRoomStart>(Arena*);
template<> ::Protocol::PWorldPos* Arena::CreateMaybeMessage<::Protocol::PWorldPos>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protocol {

// ===================================================================

class PChannel final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PChannel) */ {
 public:
  inline PChannel() : PChannel(nullptr) {}
  ~PChannel() override;
  explicit PROTOBUF_CONSTEXPR PChannel(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PChannel(const PChannel& from);
  PChannel(PChannel&& from) noexcept
    : PChannel() {
    *this = ::std::move(from);
  }

  inline PChannel& operator=(const PChannel& from) {
    CopyFrom(from);
    return *this;
  }
  inline PChannel& operator=(PChannel&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PChannel& default_instance() {
    return *internal_default_instance();
  }
  static inline const PChannel* internal_default_instance() {
    return reinterpret_cast<const PChannel*>(
               &_PChannel_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PChannel& a, PChannel& b) {
    a.Swap(&b);
  }
  inline void Swap(PChannel* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PChannel* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PChannel* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PChannel>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PChannel& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PChannel& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PChannel* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PChannel";
  }
  protected:
  explicit PChannel(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChannelIdFieldNumber = 1,
    kMaxPlayerCountFieldNumber = 2,
    kCurrentPlayerCountFieldNumber = 3,
  };
  // int32 channelId = 1;
  void clear_channelid();
  int32_t channelid() const;
  void set_channelid(int32_t value);
  private:
  int32_t _internal_channelid() const;
  void _internal_set_channelid(int32_t value);
  public:

  // int32 maxPlayerCount = 2;
  void clear_maxplayercount();
  int32_t maxplayercount() const;
  void set_maxplayercount(int32_t value);
  private:
  int32_t _internal_maxplayercount() const;
  void _internal_set_maxplayercount(int32_t value);
  public:

  // int32 currentPlayerCount = 3;
  void clear_currentplayercount();
  int32_t currentplayercount() const;
  void set_currentplayercount(int32_t value);
  private:
  int32_t _internal_currentplayercount() const;
  void _internal_set_currentplayercount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PChannel)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t channelid_;
  int32_t maxplayercount_;
  int32_t currentplayercount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class PRoom final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PRoom) */ {
 public:
  inline PRoom() : PRoom(nullptr) {}
  ~PRoom() override;
  explicit PROTOBUF_CONSTEXPR PRoom(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PRoom(const PRoom& from);
  PRoom(PRoom&& from) noexcept
    : PRoom() {
    *this = ::std::move(from);
  }

  inline PRoom& operator=(const PRoom& from) {
    CopyFrom(from);
    return *this;
  }
  inline PRoom& operator=(PRoom&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PRoom& default_instance() {
    return *internal_default_instance();
  }
  static inline const PRoom* internal_default_instance() {
    return reinterpret_cast<const PRoom*>(
               &_PRoom_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PRoom& a, PRoom& b) {
    a.Swap(&b);
  }
  inline void Swap(PRoom* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PRoom* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PRoom* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PRoom>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PRoom& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PRoom& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PRoom* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PRoom";
  }
  protected:
  explicit PRoom(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBenListFieldNumber = 6,
    kPlayerListFieldNumber = 7,
    kRoomNameFieldNumber = 2,
    kRoomIdFieldNumber = 1,
    kMaxPlayerCountFieldNumber = 4,
    kLeaderIdFieldNumber = 3,
    kCurrentPlayerCountFieldNumber = 5,
  };
  // repeated bool benList = 6;
  int benlist_size() const;
  private:
  int _internal_benlist_size() const;
  public:
  void clear_benlist();
  private:
  bool _internal_benlist(int index) const;
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      _internal_benlist() const;
  void _internal_add_benlist(bool value);
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      _internal_mutable_benlist();
  public:
  bool benlist(int index) const;
  void set_benlist(int index, bool value);
  void add_benlist(bool value);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
      benlist() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
      mutable_benlist();

  // repeated .Protocol.PPlayer playerList = 7;
  int playerlist_size() const;
  private:
  int _internal_playerlist_size() const;
  public:
  void clear_playerlist();
  ::Protocol::PPlayer* mutable_playerlist(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PPlayer >*
      mutable_playerlist();
  private:
  const ::Protocol::PPlayer& _internal_playerlist(int index) const;
  ::Protocol::PPlayer* _internal_add_playerlist();
  public:
  const ::Protocol::PPlayer& playerlist(int index) const;
  ::Protocol::PPlayer* add_playerlist();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PPlayer >&
      playerlist() const;

  // string roomName = 2;
  void clear_roomname();
  const std::string& roomname() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_roomname(ArgT0&& arg0, ArgT... args);
  std::string* mutable_roomname();
  PROTOBUF_NODISCARD std::string* release_roomname();
  void set_allocated_roomname(std::string* roomname);
  private:
  const std::string& _internal_roomname() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_roomname(const std::string& value);
  std::string* _internal_mutable_roomname();
  public:

  // int32 roomId = 1;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 maxPlayerCount = 4;
  void clear_maxplayercount();
  int32_t maxplayercount() const;
  void set_maxplayercount(int32_t value);
  private:
  int32_t _internal_maxplayercount() const;
  void _internal_set_maxplayercount(int32_t value);
  public:

  // int64 leaderId = 3;
  void clear_leaderid();
  int64_t leaderid() const;
  void set_leaderid(int64_t value);
  private:
  int64_t _internal_leaderid() const;
  void _internal_set_leaderid(int64_t value);
  public:

  // int32 currentPlayerCount = 5;
  void clear_currentplayercount();
  int32_t currentplayercount() const;
  void set_currentplayercount(int32_t value);
  private:
  int32_t _internal_currentplayercount() const;
  void _internal_set_currentplayercount(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PRoom)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool > benlist_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PPlayer > playerlist_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr roomname_;
  int32_t roomid_;
  int32_t maxplayercount_;
  int64_t leaderid_;
  int32_t currentplayercount_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class PPlayer final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PPlayer) */ {
 public:
  inline PPlayer() : PPlayer(nullptr) {}
  ~PPlayer() override;
  explicit PROTOBUF_CONSTEXPR PPlayer(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PPlayer(const PPlayer& from);
  PPlayer(PPlayer&& from) noexcept
    : PPlayer() {
    *this = ::std::move(from);
  }

  inline PPlayer& operator=(const PPlayer& from) {
    CopyFrom(from);
    return *this;
  }
  inline PPlayer& operator=(PPlayer&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PPlayer& default_instance() {
    return *internal_default_instance();
  }
  static inline const PPlayer* internal_default_instance() {
    return reinterpret_cast<const PPlayer*>(
               &_PPlayer_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(PPlayer& a, PPlayer& b) {
    a.Swap(&b);
  }
  inline void Swap(PPlayer* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PPlayer* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PPlayer* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PPlayer>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PPlayer& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PPlayer& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PPlayer* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PPlayer";
  }
  protected:
  explicit PPlayer(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerIdFieldNumber = 1,
    kNameFieldNumber = 2,
    kLevelFieldNumber = 3,
    kExpFieldNumber = 4,
    kIdFieldNumber = 5,
    kChannelIdFieldNumber = 6,
    kRoomIdFieldNumber = 7,
    kRoomIdxFieldNumber = 8,
    kReadyFieldNumber = 9,
    kSpeedFieldNumber = 10,
    kMaxBombCountFieldNumber = 11,
    kBombCountFieldNumber = 12,
    kBombRangeFieldNumber = 13,
  };
  // string playerId = 1;
  void clear_playerid();
  const std::string& playerid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_playerid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_playerid();
  PROTOBUF_NODISCARD std::string* release_playerid();
  void set_allocated_playerid(std::string* playerid);
  private:
  const std::string& _internal_playerid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_playerid(const std::string& value);
  std::string* _internal_mutable_playerid();
  public:

  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // int32 level = 3;
  void clear_level();
  int32_t level() const;
  void set_level(int32_t value);
  private:
  int32_t _internal_level() const;
  void _internal_set_level(int32_t value);
  public:

  // float exp = 4;
  void clear_exp();
  float exp() const;
  void set_exp(float value);
  private:
  float _internal_exp() const;
  void _internal_set_exp(float value);
  public:

  // int64 id = 5;
  void clear_id();
  int64_t id() const;
  void set_id(int64_t value);
  private:
  int64_t _internal_id() const;
  void _internal_set_id(int64_t value);
  public:

  // int32 channelId = 6;
  void clear_channelid();
  int32_t channelid() const;
  void set_channelid(int32_t value);
  private:
  int32_t _internal_channelid() const;
  void _internal_set_channelid(int32_t value);
  public:

  // int32 roomId = 7;
  void clear_roomid();
  int32_t roomid() const;
  void set_roomid(int32_t value);
  private:
  int32_t _internal_roomid() const;
  void _internal_set_roomid(int32_t value);
  public:

  // int32 roomIdx = 8;
  void clear_roomidx();
  int32_t roomidx() const;
  void set_roomidx(int32_t value);
  private:
  int32_t _internal_roomidx() const;
  void _internal_set_roomidx(int32_t value);
  public:

  // bool ready = 9;
  void clear_ready();
  bool ready() const;
  void set_ready(bool value);
  private:
  bool _internal_ready() const;
  void _internal_set_ready(bool value);
  public:

  // float speed = 10;
  void clear_speed();
  float speed() const;
  void set_speed(float value);
  private:
  float _internal_speed() const;
  void _internal_set_speed(float value);
  public:

  // int32 maxBombCount = 11;
  void clear_maxbombcount();
  int32_t maxbombcount() const;
  void set_maxbombcount(int32_t value);
  private:
  int32_t _internal_maxbombcount() const;
  void _internal_set_maxbombcount(int32_t value);
  public:

  // int32 bombCount = 12;
  void clear_bombcount();
  int32_t bombcount() const;
  void set_bombcount(int32_t value);
  private:
  int32_t _internal_bombcount() const;
  void _internal_set_bombcount(int32_t value);
  public:

  // int32 bombRange = 13;
  void clear_bombrange();
  int32_t bombrange() const;
  void set_bombrange(int32_t value);
  private:
  int32_t _internal_bombrange() const;
  void _internal_set_bombrange(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PPlayer)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr playerid_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  int32_t level_;
  float exp_;
  int64_t id_;
  int32_t channelid_;
  int32_t roomid_;
  int32_t roomidx_;
  bool ready_;
  float speed_;
  int32_t maxbombcount_;
  int32_t bombcount_;
  int32_t bombrange_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class PWorldPos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PWorldPos) */ {
 public:
  inline PWorldPos() : PWorldPos(nullptr) {}
  ~PWorldPos() override;
  explicit PROTOBUF_CONSTEXPR PWorldPos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PWorldPos(const PWorldPos& from);
  PWorldPos(PWorldPos&& from) noexcept
    : PWorldPos() {
    *this = ::std::move(from);
  }

  inline PWorldPos& operator=(const PWorldPos& from) {
    CopyFrom(from);
    return *this;
  }
  inline PWorldPos& operator=(PWorldPos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PWorldPos& default_instance() {
    return *internal_default_instance();
  }
  static inline const PWorldPos* internal_default_instance() {
    return reinterpret_cast<const PWorldPos*>(
               &_PWorldPos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(PWorldPos& a, PWorldPos& b) {
    a.Swap(&b);
  }
  inline void Swap(PWorldPos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PWorldPos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PWorldPos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PWorldPos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PWorldPos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PWorldPos& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PWorldPos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PWorldPos";
  }
  protected:
  explicit PWorldPos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosXFieldNumber = 1,
    kPosYFieldNumber = 2,
  };
  // float posX = 1;
  void clear_posx();
  float posx() const;
  void set_posx(float value);
  private:
  float _internal_posx() const;
  void _internal_set_posx(float value);
  public:

  // float posY = 2;
  void clear_posy();
  float posy() const;
  void set_posy(float value);
  private:
  float _internal_posy() const;
  void _internal_set_posy(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PWorldPos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  float posx_;
  float posy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class PCellPos final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PCellPos) */ {
 public:
  inline PCellPos() : PCellPos(nullptr) {}
  ~PCellPos() override;
  explicit PROTOBUF_CONSTEXPR PCellPos(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PCellPos(const PCellPos& from);
  PCellPos(PCellPos&& from) noexcept
    : PCellPos() {
    *this = ::std::move(from);
  }

  inline PCellPos& operator=(const PCellPos& from) {
    CopyFrom(from);
    return *this;
  }
  inline PCellPos& operator=(PCellPos&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PCellPos& default_instance() {
    return *internal_default_instance();
  }
  static inline const PCellPos* internal_default_instance() {
    return reinterpret_cast<const PCellPos*>(
               &_PCellPos_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(PCellPos& a, PCellPos& b) {
    a.Swap(&b);
  }
  inline void Swap(PCellPos* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PCellPos* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PCellPos* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PCellPos>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PCellPos& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PCellPos& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PCellPos* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PCellPos";
  }
  protected:
  explicit PCellPos(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPosXFieldNumber = 1,
    kPosYFieldNumber = 2,
  };
  // int32 posX = 1;
  void clear_posx();
  int32_t posx() const;
  void set_posx(int32_t value);
  private:
  int32_t _internal_posx() const;
  void _internal_set_posx(int32_t value);
  public:

  // int32 posY = 2;
  void clear_posy();
  int32_t posy() const;
  void set_posy(int32_t value);
  private:
  int32_t _internal_posy() const;
  void _internal_set_posy(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PCellPos)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  int32_t posx_;
  int32_t posy_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class PPositionInfo final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PPositionInfo) */ {
 public:
  inline PPositionInfo() : PPositionInfo(nullptr) {}
  ~PPositionInfo() override;
  explicit PROTOBUF_CONSTEXPR PPositionInfo(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PPositionInfo(const PPositionInfo& from);
  PPositionInfo(PPositionInfo&& from) noexcept
    : PPositionInfo() {
    *this = ::std::move(from);
  }

  inline PPositionInfo& operator=(const PPositionInfo& from) {
    CopyFrom(from);
    return *this;
  }
  inline PPositionInfo& operator=(PPositionInfo&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PPositionInfo& default_instance() {
    return *internal_default_instance();
  }
  static inline const PPositionInfo* internal_default_instance() {
    return reinterpret_cast<const PPositionInfo*>(
               &_PPositionInfo_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(PPositionInfo& a, PPositionInfo& b) {
    a.Swap(&b);
  }
  inline void Swap(PPositionInfo* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PPositionInfo* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PPositionInfo* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PPositionInfo>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PPositionInfo& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PPositionInfo& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PPositionInfo* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PPositionInfo";
  }
  protected:
  explicit PPositionInfo(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kWorldPosFieldNumber = 3,
    kCellPosFieldNumber = 4,
    kStateFieldNumber = 1,
    kMoveDirFieldNumber = 2,
  };
  // .Protocol.PWorldPos worldPos = 3;
  bool has_worldpos() const;
  private:
  bool _internal_has_worldpos() const;
  public:
  void clear_worldpos();
  const ::Protocol::PWorldPos& worldpos() const;
  PROTOBUF_NODISCARD ::Protocol::PWorldPos* release_worldpos();
  ::Protocol::PWorldPos* mutable_worldpos();
  void set_allocated_worldpos(::Protocol::PWorldPos* worldpos);
  private:
  const ::Protocol::PWorldPos& _internal_worldpos() const;
  ::Protocol::PWorldPos* _internal_mutable_worldpos();
  public:
  void unsafe_arena_set_allocated_worldpos(
      ::Protocol::PWorldPos* worldpos);
  ::Protocol::PWorldPos* unsafe_arena_release_worldpos();

  // .Protocol.PCellPos cellPos = 4;
  bool has_cellpos() const;
  private:
  bool _internal_has_cellpos() const;
  public:
  void clear_cellpos();
  const ::Protocol::PCellPos& cellpos() const;
  PROTOBUF_NODISCARD ::Protocol::PCellPos* release_cellpos();
  ::Protocol::PCellPos* mutable_cellpos();
  void set_allocated_cellpos(::Protocol::PCellPos* cellpos);
  private:
  const ::Protocol::PCellPos& _internal_cellpos() const;
  ::Protocol::PCellPos* _internal_mutable_cellpos();
  public:
  void unsafe_arena_set_allocated_cellpos(
      ::Protocol::PCellPos* cellpos);
  ::Protocol::PCellPos* unsafe_arena_release_cellpos();

  // .Protocol.PPlayerState state = 1;
  void clear_state();
  ::Protocol::PPlayerState state() const;
  void set_state(::Protocol::PPlayerState value);
  private:
  ::Protocol::PPlayerState _internal_state() const;
  void _internal_set_state(::Protocol::PPlayerState value);
  public:

  // .Protocol.PMoveDir moveDir = 2;
  void clear_movedir();
  ::Protocol::PMoveDir movedir() const;
  void set_movedir(::Protocol::PMoveDir value);
  private:
  ::Protocol::PMoveDir _internal_movedir() const;
  void _internal_set_movedir(::Protocol::PMoveDir value);
  public:

  // @@protoc_insertion_point(class_scope:Protocol.PPositionInfo)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PWorldPos* worldpos_;
  ::Protocol::PCellPos* cellpos_;
  int state_;
  int movedir_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// -------------------------------------------------------------------

class PRoomStart final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protocol.PRoomStart) */ {
 public:
  inline PRoomStart() : PRoomStart(nullptr) {}
  ~PRoomStart() override;
  explicit PROTOBUF_CONSTEXPR PRoomStart(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PRoomStart(const PRoomStart& from);
  PRoomStart(PRoomStart&& from) noexcept
    : PRoomStart() {
    *this = ::std::move(from);
  }

  inline PRoomStart& operator=(const PRoomStart& from) {
    CopyFrom(from);
    return *this;
  }
  inline PRoomStart& operator=(PRoomStart&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PRoomStart& default_instance() {
    return *internal_default_instance();
  }
  static inline const PRoomStart* internal_default_instance() {
    return reinterpret_cast<const PRoomStart*>(
               &_PRoomStart_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PRoomStart& a, PRoomStart& b) {
    a.Swap(&b);
  }
  inline void Swap(PRoomStart* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PRoomStart* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PRoomStart* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PRoomStart>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PRoomStart& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PRoomStart& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PRoomStart* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protocol.PRoomStart";
  }
  protected:
  explicit PRoomStart(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPlayerInfoFieldNumber = 1,
    kPosInfoFieldNumber = 2,
  };
  // .Protocol.PPlayer playerInfo = 1;
  bool has_playerinfo() const;
  private:
  bool _internal_has_playerinfo() const;
  public:
  void clear_playerinfo();
  const ::Protocol::PPlayer& playerinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PPlayer* release_playerinfo();
  ::Protocol::PPlayer* mutable_playerinfo();
  void set_allocated_playerinfo(::Protocol::PPlayer* playerinfo);
  private:
  const ::Protocol::PPlayer& _internal_playerinfo() const;
  ::Protocol::PPlayer* _internal_mutable_playerinfo();
  public:
  void unsafe_arena_set_allocated_playerinfo(
      ::Protocol::PPlayer* playerinfo);
  ::Protocol::PPlayer* unsafe_arena_release_playerinfo();

  // .Protocol.PPositionInfo posInfo = 2;
  bool has_posinfo() const;
  private:
  bool _internal_has_posinfo() const;
  public:
  void clear_posinfo();
  const ::Protocol::PPositionInfo& posinfo() const;
  PROTOBUF_NODISCARD ::Protocol::PPositionInfo* release_posinfo();
  ::Protocol::PPositionInfo* mutable_posinfo();
  void set_allocated_posinfo(::Protocol::PPositionInfo* posinfo);
  private:
  const ::Protocol::PPositionInfo& _internal_posinfo() const;
  ::Protocol::PPositionInfo* _internal_mutable_posinfo();
  public:
  void unsafe_arena_set_allocated_posinfo(
      ::Protocol::PPositionInfo* posinfo);
  ::Protocol::PPositionInfo* unsafe_arena_release_posinfo();

  // @@protoc_insertion_point(class_scope:Protocol.PRoomStart)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Protocol::PPlayer* playerinfo_;
  ::Protocol::PPositionInfo* posinfo_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_Struct_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PChannel

// int32 channelId = 1;
inline void PChannel::clear_channelid() {
  channelid_ = 0;
}
inline int32_t PChannel::_internal_channelid() const {
  return channelid_;
}
inline int32_t PChannel::channelid() const {
  // @@protoc_insertion_point(field_get:Protocol.PChannel.channelId)
  return _internal_channelid();
}
inline void PChannel::_internal_set_channelid(int32_t value) {
  
  channelid_ = value;
}
inline void PChannel::set_channelid(int32_t value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:Protocol.PChannel.channelId)
}

// int32 maxPlayerCount = 2;
inline void PChannel::clear_maxplayercount() {
  maxplayercount_ = 0;
}
inline int32_t PChannel::_internal_maxplayercount() const {
  return maxplayercount_;
}
inline int32_t PChannel::maxplayercount() const {
  // @@protoc_insertion_point(field_get:Protocol.PChannel.maxPlayerCount)
  return _internal_maxplayercount();
}
inline void PChannel::_internal_set_maxplayercount(int32_t value) {
  
  maxplayercount_ = value;
}
inline void PChannel::set_maxplayercount(int32_t value) {
  _internal_set_maxplayercount(value);
  // @@protoc_insertion_point(field_set:Protocol.PChannel.maxPlayerCount)
}

// int32 currentPlayerCount = 3;
inline void PChannel::clear_currentplayercount() {
  currentplayercount_ = 0;
}
inline int32_t PChannel::_internal_currentplayercount() const {
  return currentplayercount_;
}
inline int32_t PChannel::currentplayercount() const {
  // @@protoc_insertion_point(field_get:Protocol.PChannel.currentPlayerCount)
  return _internal_currentplayercount();
}
inline void PChannel::_internal_set_currentplayercount(int32_t value) {
  
  currentplayercount_ = value;
}
inline void PChannel::set_currentplayercount(int32_t value) {
  _internal_set_currentplayercount(value);
  // @@protoc_insertion_point(field_set:Protocol.PChannel.currentPlayerCount)
}

// -------------------------------------------------------------------

// PRoom

// int32 roomId = 1;
inline void PRoom::clear_roomid() {
  roomid_ = 0;
}
inline int32_t PRoom::_internal_roomid() const {
  return roomid_;
}
inline int32_t PRoom::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.PRoom.roomId)
  return _internal_roomid();
}
inline void PRoom::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void PRoom::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.PRoom.roomId)
}

// string roomName = 2;
inline void PRoom::clear_roomname() {
  roomname_.ClearToEmpty();
}
inline const std::string& PRoom::roomname() const {
  // @@protoc_insertion_point(field_get:Protocol.PRoom.roomName)
  return _internal_roomname();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PRoom::set_roomname(ArgT0&& arg0, ArgT... args) {
 
 roomname_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PRoom.roomName)
}
inline std::string* PRoom::mutable_roomname() {
  std::string* _s = _internal_mutable_roomname();
  // @@protoc_insertion_point(field_mutable:Protocol.PRoom.roomName)
  return _s;
}
inline const std::string& PRoom::_internal_roomname() const {
  return roomname_.Get();
}
inline void PRoom::_internal_set_roomname(const std::string& value) {
  
  roomname_.Set(value, GetArenaForAllocation());
}
inline std::string* PRoom::_internal_mutable_roomname() {
  
  return roomname_.Mutable(GetArenaForAllocation());
}
inline std::string* PRoom::release_roomname() {
  // @@protoc_insertion_point(field_release:Protocol.PRoom.roomName)
  return roomname_.Release();
}
inline void PRoom::set_allocated_roomname(std::string* roomname) {
  if (roomname != nullptr) {
    
  } else {
    
  }
  roomname_.SetAllocated(roomname, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (roomname_.IsDefault()) {
    roomname_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PRoom.roomName)
}

// int64 leaderId = 3;
inline void PRoom::clear_leaderid() {
  leaderid_ = int64_t{0};
}
inline int64_t PRoom::_internal_leaderid() const {
  return leaderid_;
}
inline int64_t PRoom::leaderid() const {
  // @@protoc_insertion_point(field_get:Protocol.PRoom.leaderId)
  return _internal_leaderid();
}
inline void PRoom::_internal_set_leaderid(int64_t value) {
  
  leaderid_ = value;
}
inline void PRoom::set_leaderid(int64_t value) {
  _internal_set_leaderid(value);
  // @@protoc_insertion_point(field_set:Protocol.PRoom.leaderId)
}

// int32 maxPlayerCount = 4;
inline void PRoom::clear_maxplayercount() {
  maxplayercount_ = 0;
}
inline int32_t PRoom::_internal_maxplayercount() const {
  return maxplayercount_;
}
inline int32_t PRoom::maxplayercount() const {
  // @@protoc_insertion_point(field_get:Protocol.PRoom.maxPlayerCount)
  return _internal_maxplayercount();
}
inline void PRoom::_internal_set_maxplayercount(int32_t value) {
  
  maxplayercount_ = value;
}
inline void PRoom::set_maxplayercount(int32_t value) {
  _internal_set_maxplayercount(value);
  // @@protoc_insertion_point(field_set:Protocol.PRoom.maxPlayerCount)
}

// int32 currentPlayerCount = 5;
inline void PRoom::clear_currentplayercount() {
  currentplayercount_ = 0;
}
inline int32_t PRoom::_internal_currentplayercount() const {
  return currentplayercount_;
}
inline int32_t PRoom::currentplayercount() const {
  // @@protoc_insertion_point(field_get:Protocol.PRoom.currentPlayerCount)
  return _internal_currentplayercount();
}
inline void PRoom::_internal_set_currentplayercount(int32_t value) {
  
  currentplayercount_ = value;
}
inline void PRoom::set_currentplayercount(int32_t value) {
  _internal_set_currentplayercount(value);
  // @@protoc_insertion_point(field_set:Protocol.PRoom.currentPlayerCount)
}

// repeated bool benList = 6;
inline int PRoom::_internal_benlist_size() const {
  return benlist_.size();
}
inline int PRoom::benlist_size() const {
  return _internal_benlist_size();
}
inline void PRoom::clear_benlist() {
  benlist_.Clear();
}
inline bool PRoom::_internal_benlist(int index) const {
  return benlist_.Get(index);
}
inline bool PRoom::benlist(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.PRoom.benList)
  return _internal_benlist(index);
}
inline void PRoom::set_benlist(int index, bool value) {
  benlist_.Set(index, value);
  // @@protoc_insertion_point(field_set:Protocol.PRoom.benList)
}
inline void PRoom::_internal_add_benlist(bool value) {
  benlist_.Add(value);
}
inline void PRoom::add_benlist(bool value) {
  _internal_add_benlist(value);
  // @@protoc_insertion_point(field_add:Protocol.PRoom.benList)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
PRoom::_internal_benlist() const {
  return benlist_;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >&
PRoom::benlist() const {
  // @@protoc_insertion_point(field_list:Protocol.PRoom.benList)
  return _internal_benlist();
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
PRoom::_internal_mutable_benlist() {
  return &benlist_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedField< bool >*
PRoom::mutable_benlist() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.PRoom.benList)
  return _internal_mutable_benlist();
}

// repeated .Protocol.PPlayer playerList = 7;
inline int PRoom::_internal_playerlist_size() const {
  return playerlist_.size();
}
inline int PRoom::playerlist_size() const {
  return _internal_playerlist_size();
}
inline void PRoom::clear_playerlist() {
  playerlist_.Clear();
}
inline ::Protocol::PPlayer* PRoom::mutable_playerlist(int index) {
  // @@protoc_insertion_point(field_mutable:Protocol.PRoom.playerList)
  return playerlist_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PPlayer >*
PRoom::mutable_playerlist() {
  // @@protoc_insertion_point(field_mutable_list:Protocol.PRoom.playerList)
  return &playerlist_;
}
inline const ::Protocol::PPlayer& PRoom::_internal_playerlist(int index) const {
  return playerlist_.Get(index);
}
inline const ::Protocol::PPlayer& PRoom::playerlist(int index) const {
  // @@protoc_insertion_point(field_get:Protocol.PRoom.playerList)
  return _internal_playerlist(index);
}
inline ::Protocol::PPlayer* PRoom::_internal_add_playerlist() {
  return playerlist_.Add();
}
inline ::Protocol::PPlayer* PRoom::add_playerlist() {
  ::Protocol::PPlayer* _add = _internal_add_playerlist();
  // @@protoc_insertion_point(field_add:Protocol.PRoom.playerList)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protocol::PPlayer >&
PRoom::playerlist() const {
  // @@protoc_insertion_point(field_list:Protocol.PRoom.playerList)
  return playerlist_;
}

// -------------------------------------------------------------------

// PPlayer

// string playerId = 1;
inline void PPlayer::clear_playerid() {
  playerid_.ClearToEmpty();
}
inline const std::string& PPlayer::playerid() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.playerId)
  return _internal_playerid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PPlayer::set_playerid(ArgT0&& arg0, ArgT... args) {
 
 playerid_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.playerId)
}
inline std::string* PPlayer::mutable_playerid() {
  std::string* _s = _internal_mutable_playerid();
  // @@protoc_insertion_point(field_mutable:Protocol.PPlayer.playerId)
  return _s;
}
inline const std::string& PPlayer::_internal_playerid() const {
  return playerid_.Get();
}
inline void PPlayer::_internal_set_playerid(const std::string& value) {
  
  playerid_.Set(value, GetArenaForAllocation());
}
inline std::string* PPlayer::_internal_mutable_playerid() {
  
  return playerid_.Mutable(GetArenaForAllocation());
}
inline std::string* PPlayer::release_playerid() {
  // @@protoc_insertion_point(field_release:Protocol.PPlayer.playerId)
  return playerid_.Release();
}
inline void PPlayer::set_allocated_playerid(std::string* playerid) {
  if (playerid != nullptr) {
    
  } else {
    
  }
  playerid_.SetAllocated(playerid, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (playerid_.IsDefault()) {
    playerid_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PPlayer.playerId)
}

// string name = 2;
inline void PPlayer::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& PPlayer::name() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void PPlayer::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.name)
}
inline std::string* PPlayer::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Protocol.PPlayer.name)
  return _s;
}
inline const std::string& PPlayer::_internal_name() const {
  return name_.Get();
}
inline void PPlayer::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* PPlayer::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* PPlayer::release_name() {
  // @@protoc_insertion_point(field_release:Protocol.PPlayer.name)
  return name_.Release();
}
inline void PPlayer::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protocol.PPlayer.name)
}

// int32 level = 3;
inline void PPlayer::clear_level() {
  level_ = 0;
}
inline int32_t PPlayer::_internal_level() const {
  return level_;
}
inline int32_t PPlayer::level() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.level)
  return _internal_level();
}
inline void PPlayer::_internal_set_level(int32_t value) {
  
  level_ = value;
}
inline void PPlayer::set_level(int32_t value) {
  _internal_set_level(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.level)
}

// float exp = 4;
inline void PPlayer::clear_exp() {
  exp_ = 0;
}
inline float PPlayer::_internal_exp() const {
  return exp_;
}
inline float PPlayer::exp() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.exp)
  return _internal_exp();
}
inline void PPlayer::_internal_set_exp(float value) {
  
  exp_ = value;
}
inline void PPlayer::set_exp(float value) {
  _internal_set_exp(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.exp)
}

// int64 id = 5;
inline void PPlayer::clear_id() {
  id_ = int64_t{0};
}
inline int64_t PPlayer::_internal_id() const {
  return id_;
}
inline int64_t PPlayer::id() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.id)
  return _internal_id();
}
inline void PPlayer::_internal_set_id(int64_t value) {
  
  id_ = value;
}
inline void PPlayer::set_id(int64_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.id)
}

// int32 channelId = 6;
inline void PPlayer::clear_channelid() {
  channelid_ = 0;
}
inline int32_t PPlayer::_internal_channelid() const {
  return channelid_;
}
inline int32_t PPlayer::channelid() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.channelId)
  return _internal_channelid();
}
inline void PPlayer::_internal_set_channelid(int32_t value) {
  
  channelid_ = value;
}
inline void PPlayer::set_channelid(int32_t value) {
  _internal_set_channelid(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.channelId)
}

// int32 roomId = 7;
inline void PPlayer::clear_roomid() {
  roomid_ = 0;
}
inline int32_t PPlayer::_internal_roomid() const {
  return roomid_;
}
inline int32_t PPlayer::roomid() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.roomId)
  return _internal_roomid();
}
inline void PPlayer::_internal_set_roomid(int32_t value) {
  
  roomid_ = value;
}
inline void PPlayer::set_roomid(int32_t value) {
  _internal_set_roomid(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.roomId)
}

// int32 roomIdx = 8;
inline void PPlayer::clear_roomidx() {
  roomidx_ = 0;
}
inline int32_t PPlayer::_internal_roomidx() const {
  return roomidx_;
}
inline int32_t PPlayer::roomidx() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.roomIdx)
  return _internal_roomidx();
}
inline void PPlayer::_internal_set_roomidx(int32_t value) {
  
  roomidx_ = value;
}
inline void PPlayer::set_roomidx(int32_t value) {
  _internal_set_roomidx(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.roomIdx)
}

// bool ready = 9;
inline void PPlayer::clear_ready() {
  ready_ = false;
}
inline bool PPlayer::_internal_ready() const {
  return ready_;
}
inline bool PPlayer::ready() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.ready)
  return _internal_ready();
}
inline void PPlayer::_internal_set_ready(bool value) {
  
  ready_ = value;
}
inline void PPlayer::set_ready(bool value) {
  _internal_set_ready(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.ready)
}

// float speed = 10;
inline void PPlayer::clear_speed() {
  speed_ = 0;
}
inline float PPlayer::_internal_speed() const {
  return speed_;
}
inline float PPlayer::speed() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.speed)
  return _internal_speed();
}
inline void PPlayer::_internal_set_speed(float value) {
  
  speed_ = value;
}
inline void PPlayer::set_speed(float value) {
  _internal_set_speed(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.speed)
}

// int32 maxBombCount = 11;
inline void PPlayer::clear_maxbombcount() {
  maxbombcount_ = 0;
}
inline int32_t PPlayer::_internal_maxbombcount() const {
  return maxbombcount_;
}
inline int32_t PPlayer::maxbombcount() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.maxBombCount)
  return _internal_maxbombcount();
}
inline void PPlayer::_internal_set_maxbombcount(int32_t value) {
  
  maxbombcount_ = value;
}
inline void PPlayer::set_maxbombcount(int32_t value) {
  _internal_set_maxbombcount(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.maxBombCount)
}

// int32 bombCount = 12;
inline void PPlayer::clear_bombcount() {
  bombcount_ = 0;
}
inline int32_t PPlayer::_internal_bombcount() const {
  return bombcount_;
}
inline int32_t PPlayer::bombcount() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.bombCount)
  return _internal_bombcount();
}
inline void PPlayer::_internal_set_bombcount(int32_t value) {
  
  bombcount_ = value;
}
inline void PPlayer::set_bombcount(int32_t value) {
  _internal_set_bombcount(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.bombCount)
}

// int32 bombRange = 13;
inline void PPlayer::clear_bombrange() {
  bombrange_ = 0;
}
inline int32_t PPlayer::_internal_bombrange() const {
  return bombrange_;
}
inline int32_t PPlayer::bombrange() const {
  // @@protoc_insertion_point(field_get:Protocol.PPlayer.bombRange)
  return _internal_bombrange();
}
inline void PPlayer::_internal_set_bombrange(int32_t value) {
  
  bombrange_ = value;
}
inline void PPlayer::set_bombrange(int32_t value) {
  _internal_set_bombrange(value);
  // @@protoc_insertion_point(field_set:Protocol.PPlayer.bombRange)
}

// -------------------------------------------------------------------

// PWorldPos

// float posX = 1;
inline void PWorldPos::clear_posx() {
  posx_ = 0;
}
inline float PWorldPos::_internal_posx() const {
  return posx_;
}
inline float PWorldPos::posx() const {
  // @@protoc_insertion_point(field_get:Protocol.PWorldPos.posX)
  return _internal_posx();
}
inline void PWorldPos::_internal_set_posx(float value) {
  
  posx_ = value;
}
inline void PWorldPos::set_posx(float value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:Protocol.PWorldPos.posX)
}

// float posY = 2;
inline void PWorldPos::clear_posy() {
  posy_ = 0;
}
inline float PWorldPos::_internal_posy() const {
  return posy_;
}
inline float PWorldPos::posy() const {
  // @@protoc_insertion_point(field_get:Protocol.PWorldPos.posY)
  return _internal_posy();
}
inline void PWorldPos::_internal_set_posy(float value) {
  
  posy_ = value;
}
inline void PWorldPos::set_posy(float value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:Protocol.PWorldPos.posY)
}

// -------------------------------------------------------------------

// PCellPos

// int32 posX = 1;
inline void PCellPos::clear_posx() {
  posx_ = 0;
}
inline int32_t PCellPos::_internal_posx() const {
  return posx_;
}
inline int32_t PCellPos::posx() const {
  // @@protoc_insertion_point(field_get:Protocol.PCellPos.posX)
  return _internal_posx();
}
inline void PCellPos::_internal_set_posx(int32_t value) {
  
  posx_ = value;
}
inline void PCellPos::set_posx(int32_t value) {
  _internal_set_posx(value);
  // @@protoc_insertion_point(field_set:Protocol.PCellPos.posX)
}

// int32 posY = 2;
inline void PCellPos::clear_posy() {
  posy_ = 0;
}
inline int32_t PCellPos::_internal_posy() const {
  return posy_;
}
inline int32_t PCellPos::posy() const {
  // @@protoc_insertion_point(field_get:Protocol.PCellPos.posY)
  return _internal_posy();
}
inline void PCellPos::_internal_set_posy(int32_t value) {
  
  posy_ = value;
}
inline void PCellPos::set_posy(int32_t value) {
  _internal_set_posy(value);
  // @@protoc_insertion_point(field_set:Protocol.PCellPos.posY)
}

// -------------------------------------------------------------------

// PPositionInfo

// .Protocol.PPlayerState state = 1;
inline void PPositionInfo::clear_state() {
  state_ = 0;
}
inline ::Protocol::PPlayerState PPositionInfo::_internal_state() const {
  return static_cast< ::Protocol::PPlayerState >(state_);
}
inline ::Protocol::PPlayerState PPositionInfo::state() const {
  // @@protoc_insertion_point(field_get:Protocol.PPositionInfo.state)
  return _internal_state();
}
inline void PPositionInfo::_internal_set_state(::Protocol::PPlayerState value) {
  
  state_ = value;
}
inline void PPositionInfo::set_state(::Protocol::PPlayerState value) {
  _internal_set_state(value);
  // @@protoc_insertion_point(field_set:Protocol.PPositionInfo.state)
}

// .Protocol.PMoveDir moveDir = 2;
inline void PPositionInfo::clear_movedir() {
  movedir_ = 0;
}
inline ::Protocol::PMoveDir PPositionInfo::_internal_movedir() const {
  return static_cast< ::Protocol::PMoveDir >(movedir_);
}
inline ::Protocol::PMoveDir PPositionInfo::movedir() const {
  // @@protoc_insertion_point(field_get:Protocol.PPositionInfo.moveDir)
  return _internal_movedir();
}
inline void PPositionInfo::_internal_set_movedir(::Protocol::PMoveDir value) {
  
  movedir_ = value;
}
inline void PPositionInfo::set_movedir(::Protocol::PMoveDir value) {
  _internal_set_movedir(value);
  // @@protoc_insertion_point(field_set:Protocol.PPositionInfo.moveDir)
}

// .Protocol.PWorldPos worldPos = 3;
inline bool PPositionInfo::_internal_has_worldpos() const {
  return this != internal_default_instance() && worldpos_ != nullptr;
}
inline bool PPositionInfo::has_worldpos() const {
  return _internal_has_worldpos();
}
inline void PPositionInfo::clear_worldpos() {
  if (GetArenaForAllocation() == nullptr && worldpos_ != nullptr) {
    delete worldpos_;
  }
  worldpos_ = nullptr;
}
inline const ::Protocol::PWorldPos& PPositionInfo::_internal_worldpos() const {
  const ::Protocol::PWorldPos* p = worldpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PWorldPos&>(
      ::Protocol::_PWorldPos_default_instance_);
}
inline const ::Protocol::PWorldPos& PPositionInfo::worldpos() const {
  // @@protoc_insertion_point(field_get:Protocol.PPositionInfo.worldPos)
  return _internal_worldpos();
}
inline void PPositionInfo::unsafe_arena_set_allocated_worldpos(
    ::Protocol::PWorldPos* worldpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(worldpos_);
  }
  worldpos_ = worldpos;
  if (worldpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PPositionInfo.worldPos)
}
inline ::Protocol::PWorldPos* PPositionInfo::release_worldpos() {
  
  ::Protocol::PWorldPos* temp = worldpos_;
  worldpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PWorldPos* PPositionInfo::unsafe_arena_release_worldpos() {
  // @@protoc_insertion_point(field_release:Protocol.PPositionInfo.worldPos)
  
  ::Protocol::PWorldPos* temp = worldpos_;
  worldpos_ = nullptr;
  return temp;
}
inline ::Protocol::PWorldPos* PPositionInfo::_internal_mutable_worldpos() {
  
  if (worldpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PWorldPos>(GetArenaForAllocation());
    worldpos_ = p;
  }
  return worldpos_;
}
inline ::Protocol::PWorldPos* PPositionInfo::mutable_worldpos() {
  ::Protocol::PWorldPos* _msg = _internal_mutable_worldpos();
  // @@protoc_insertion_point(field_mutable:Protocol.PPositionInfo.worldPos)
  return _msg;
}
inline void PPositionInfo::set_allocated_worldpos(::Protocol::PWorldPos* worldpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete worldpos_;
  }
  if (worldpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(worldpos);
    if (message_arena != submessage_arena) {
      worldpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, worldpos, submessage_arena);
    }
    
  } else {
    
  }
  worldpos_ = worldpos;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PPositionInfo.worldPos)
}

// .Protocol.PCellPos cellPos = 4;
inline bool PPositionInfo::_internal_has_cellpos() const {
  return this != internal_default_instance() && cellpos_ != nullptr;
}
inline bool PPositionInfo::has_cellpos() const {
  return _internal_has_cellpos();
}
inline void PPositionInfo::clear_cellpos() {
  if (GetArenaForAllocation() == nullptr && cellpos_ != nullptr) {
    delete cellpos_;
  }
  cellpos_ = nullptr;
}
inline const ::Protocol::PCellPos& PPositionInfo::_internal_cellpos() const {
  const ::Protocol::PCellPos* p = cellpos_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PCellPos&>(
      ::Protocol::_PCellPos_default_instance_);
}
inline const ::Protocol::PCellPos& PPositionInfo::cellpos() const {
  // @@protoc_insertion_point(field_get:Protocol.PPositionInfo.cellPos)
  return _internal_cellpos();
}
inline void PPositionInfo::unsafe_arena_set_allocated_cellpos(
    ::Protocol::PCellPos* cellpos) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(cellpos_);
  }
  cellpos_ = cellpos;
  if (cellpos) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PPositionInfo.cellPos)
}
inline ::Protocol::PCellPos* PPositionInfo::release_cellpos() {
  
  ::Protocol::PCellPos* temp = cellpos_;
  cellpos_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PCellPos* PPositionInfo::unsafe_arena_release_cellpos() {
  // @@protoc_insertion_point(field_release:Protocol.PPositionInfo.cellPos)
  
  ::Protocol::PCellPos* temp = cellpos_;
  cellpos_ = nullptr;
  return temp;
}
inline ::Protocol::PCellPos* PPositionInfo::_internal_mutable_cellpos() {
  
  if (cellpos_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PCellPos>(GetArenaForAllocation());
    cellpos_ = p;
  }
  return cellpos_;
}
inline ::Protocol::PCellPos* PPositionInfo::mutable_cellpos() {
  ::Protocol::PCellPos* _msg = _internal_mutable_cellpos();
  // @@protoc_insertion_point(field_mutable:Protocol.PPositionInfo.cellPos)
  return _msg;
}
inline void PPositionInfo::set_allocated_cellpos(::Protocol::PCellPos* cellpos) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete cellpos_;
  }
  if (cellpos) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(cellpos);
    if (message_arena != submessage_arena) {
      cellpos = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, cellpos, submessage_arena);
    }
    
  } else {
    
  }
  cellpos_ = cellpos;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PPositionInfo.cellPos)
}

// -------------------------------------------------------------------

// PRoomStart

// .Protocol.PPlayer playerInfo = 1;
inline bool PRoomStart::_internal_has_playerinfo() const {
  return this != internal_default_instance() && playerinfo_ != nullptr;
}
inline bool PRoomStart::has_playerinfo() const {
  return _internal_has_playerinfo();
}
inline void PRoomStart::clear_playerinfo() {
  if (GetArenaForAllocation() == nullptr && playerinfo_ != nullptr) {
    delete playerinfo_;
  }
  playerinfo_ = nullptr;
}
inline const ::Protocol::PPlayer& PRoomStart::_internal_playerinfo() const {
  const ::Protocol::PPlayer* p = playerinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PPlayer&>(
      ::Protocol::_PPlayer_default_instance_);
}
inline const ::Protocol::PPlayer& PRoomStart::playerinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.PRoomStart.playerInfo)
  return _internal_playerinfo();
}
inline void PRoomStart::unsafe_arena_set_allocated_playerinfo(
    ::Protocol::PPlayer* playerinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(playerinfo_);
  }
  playerinfo_ = playerinfo;
  if (playerinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PRoomStart.playerInfo)
}
inline ::Protocol::PPlayer* PRoomStart::release_playerinfo() {
  
  ::Protocol::PPlayer* temp = playerinfo_;
  playerinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PPlayer* PRoomStart::unsafe_arena_release_playerinfo() {
  // @@protoc_insertion_point(field_release:Protocol.PRoomStart.playerInfo)
  
  ::Protocol::PPlayer* temp = playerinfo_;
  playerinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PPlayer* PRoomStart::_internal_mutable_playerinfo() {
  
  if (playerinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PPlayer>(GetArenaForAllocation());
    playerinfo_ = p;
  }
  return playerinfo_;
}
inline ::Protocol::PPlayer* PRoomStart::mutable_playerinfo() {
  ::Protocol::PPlayer* _msg = _internal_mutable_playerinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.PRoomStart.playerInfo)
  return _msg;
}
inline void PRoomStart::set_allocated_playerinfo(::Protocol::PPlayer* playerinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete playerinfo_;
  }
  if (playerinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(playerinfo);
    if (message_arena != submessage_arena) {
      playerinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, playerinfo, submessage_arena);
    }
    
  } else {
    
  }
  playerinfo_ = playerinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PRoomStart.playerInfo)
}

// .Protocol.PPositionInfo posInfo = 2;
inline bool PRoomStart::_internal_has_posinfo() const {
  return this != internal_default_instance() && posinfo_ != nullptr;
}
inline bool PRoomStart::has_posinfo() const {
  return _internal_has_posinfo();
}
inline void PRoomStart::clear_posinfo() {
  if (GetArenaForAllocation() == nullptr && posinfo_ != nullptr) {
    delete posinfo_;
  }
  posinfo_ = nullptr;
}
inline const ::Protocol::PPositionInfo& PRoomStart::_internal_posinfo() const {
  const ::Protocol::PPositionInfo* p = posinfo_;
  return p != nullptr ? *p : reinterpret_cast<const ::Protocol::PPositionInfo&>(
      ::Protocol::_PPositionInfo_default_instance_);
}
inline const ::Protocol::PPositionInfo& PRoomStart::posinfo() const {
  // @@protoc_insertion_point(field_get:Protocol.PRoomStart.posInfo)
  return _internal_posinfo();
}
inline void PRoomStart::unsafe_arena_set_allocated_posinfo(
    ::Protocol::PPositionInfo* posinfo) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(posinfo_);
  }
  posinfo_ = posinfo;
  if (posinfo) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Protocol.PRoomStart.posInfo)
}
inline ::Protocol::PPositionInfo* PRoomStart::release_posinfo() {
  
  ::Protocol::PPositionInfo* temp = posinfo_;
  posinfo_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Protocol::PPositionInfo* PRoomStart::unsafe_arena_release_posinfo() {
  // @@protoc_insertion_point(field_release:Protocol.PRoomStart.posInfo)
  
  ::Protocol::PPositionInfo* temp = posinfo_;
  posinfo_ = nullptr;
  return temp;
}
inline ::Protocol::PPositionInfo* PRoomStart::_internal_mutable_posinfo() {
  
  if (posinfo_ == nullptr) {
    auto* p = CreateMaybeMessage<::Protocol::PPositionInfo>(GetArenaForAllocation());
    posinfo_ = p;
  }
  return posinfo_;
}
inline ::Protocol::PPositionInfo* PRoomStart::mutable_posinfo() {
  ::Protocol::PPositionInfo* _msg = _internal_mutable_posinfo();
  // @@protoc_insertion_point(field_mutable:Protocol.PRoomStart.posInfo)
  return _msg;
}
inline void PRoomStart::set_allocated_posinfo(::Protocol::PPositionInfo* posinfo) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete posinfo_;
  }
  if (posinfo) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(posinfo);
    if (message_arena != submessage_arena) {
      posinfo = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, posinfo, submessage_arena);
    }
    
  } else {
    
  }
  posinfo_ = posinfo;
  // @@protoc_insertion_point(field_set_allocated:Protocol.PRoomStart.posInfo)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protocol

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_Struct_2eproto
